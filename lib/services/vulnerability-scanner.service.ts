/**
 * Vulnerability Scanner Service
 * Performs real vulnerability scanning using multiple techniques
 */

import { makeHttpRequest, extractSecurityHeaders } from '../utils/http-client';
import { Vulnerability } from '../types/scan-results';

export interface VulnerabilityScanOptions {
  checkHeaders?: boolean;
  checkTLS?: boolean;
  checkCookies?: boolean;
  checkCORS?: boolean;
  checkCSP?: boolean;
  deepScan?: boolean;
}

export class VulnerabilityScanner {
  /**
   * Performs a comprehensive vulnerability scan on a target
   */
  async scan(target: string, options: VulnerabilityScanOptions = {}): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Default to all checks enabled
    const opts = {
      checkHeaders: true,
      checkTLS: true,
      checkCookies: true,
      checkCORS: true,
      checkCSP: true,
      deepScan: false,
      ...options,
    };

    try {
      // Ensure target has protocol
      const url = target.startsWith('http') ? target : `https://${target}`;
      
      // Make HTTP request to get headers
      const response = await makeHttpRequest(url, { 
        method: 'GET',
        timeout: 15000,
      });

      // Check security headers
      if (opts.checkHeaders) {
        vulnerabilities.push(...this.checkSecurityHeaders(response.headers, target));
      }

      // Check TLS/SSL configuration
      if (opts.checkTLS) {
        vulnerabilities.push(...await this.checkTLSConfiguration(url));
      }

      // Check cookie security
      if (opts.checkCookies) {
        vulnerabilities.push(...this.checkCookieSecurity(response.headers, target));
      }

      // Check CORS configuration
      if (opts.checkCORS) {
        vulnerabilities.push(...this.checkCORSConfiguration(response.headers, target));
      }

      // Check Content Security Policy
      if (opts.checkCSP) {
        vulnerabilities.push(...this.checkCSP(response.headers, target));
      }

      // Deep scan for additional vulnerabilities
      if (opts.deepScan) {
        vulnerabilities.push(...await this.performDeepScan(url, response));
      }

    } catch (error) {
      console.error('Vulnerability scan error:', error);
      // Return at least one vulnerability indicating scan failure
      vulnerabilities.push({
        id: 'scan-error',
        severity: 'medium',
        title: 'Scan Incomplete',
        description: `Unable to complete full vulnerability scan: ${error instanceof Error ? error.message : 'Unknown error'}`,
        cause: 'Target may be unreachable, blocking requests, or behind a firewall.',
        affected: 'Scan Process',
        recommendation: 'Verify target is accessible and try again. Some checks may require direct server access.',
        hasSolution: false,
      });
    }

    return vulnerabilities;
  }

  /**
   * Checks for missing or misconfigured security headers
   */
  private checkSecurityHeaders(headers: Record<string, string>, target: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const missingHeaders: string[] = [];
    const weakHeaders: string[] = [];

    // Required security headers
    const requiredHeaders = {
      'content-security-policy': 'Content-Security-Policy',
      'x-frame-options': 'X-Frame-Options',
      'x-content-type-options': 'X-Content-Type-Options',
      'strict-transport-security': 'Strict-Transport-Security',
      'x-xss-protection': 'X-XSS-Protection',
      'referrer-policy': 'Referrer-Policy',
      'permissions-policy': 'Permissions-Policy',
    };

    // Check for missing headers
    for (const [key, name] of Object.entries(requiredHeaders)) {
      if (!headers[key]) {
        missingHeaders.push(name);
      }
    }

    // Check for weak configurations
    if (headers['x-frame-options'] && 
        !['DENY', 'SAMEORIGIN'].includes(headers['x-frame-options'].toUpperCase())) {
      weakHeaders.push('X-Frame-Options has weak configuration');
    }

    if (headers['strict-transport-security']) {
      const hsts = headers['strict-transport-security'];
      if (!hsts.includes('max-age') || parseInt(hsts.match(/max-age=(\d+)/)?.[1] || '0') < 31536000) {
        weakHeaders.push('HSTS max-age is too short (should be at least 1 year)');
      }
    }

    // Create vulnerability if headers are missing
    if (missingHeaders.length > 0) {
      vulnerabilities.push({
        id: 'missing-security-headers',
        severity: 'high',
        title: 'Missing Security Headers',
        description: `The target ${target} is missing ${missingHeaders.length} critical security headers: ${missingHeaders.join(', ')}`,
        cause: 'Security headers are not configured in the web server or application framework.',
        affected: 'HTTP Response Headers',
        recommendation: `Implement the following headers: ${missingHeaders.join(', ')}`,
        hasSolution: true,
      });
    }

    // Create vulnerability for weak configurations
    if (weakHeaders.length > 0) {
      vulnerabilities.push({
        id: 'weak-security-headers',
        severity: 'medium',
        title: 'Weak Security Header Configuration',
        description: `Some security headers are present but weakly configured: ${weakHeaders.join('; ')}`,
        cause: 'Security headers exist but use insecure or outdated values.',
        affected: 'HTTP Response Headers',
        recommendation: 'Review and strengthen security header configurations.',
        hasSolution: true,
      });
    }

    return vulnerabilities;
  }

  /**
   * Checks TLS/SSL configuration
   */
  private async checkTLSConfiguration(url: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Check if HTTPS is used
      if (!url.startsWith('https://')) {
        vulnerabilities.push({
          id: 'no-https',
          severity: 'critical',
          title: 'No HTTPS Encryption',
          description: 'The target does not use HTTPS, transmitting data in plain text.',
          cause: 'SSL/TLS certificate is not installed or HTTPS is not configured.',
          affected: 'Transport Layer Security',
          recommendation: 'Install an SSL/TLS certificate and configure HTTPS. Use Let\'s Encrypt for free certificates.',
          hasSolution: true,
        });
        return vulnerabilities;
      }

      // Try to detect TLS version (limited in browser/Node.js environment)
      // In production, you'd use tools like testssl.sh or ssllabs API
      const response = await makeHttpRequest(url, { method: 'HEAD', timeout: 10000 });
      
      // Check for HSTS header
      if (!response.headers['strict-transport-security']) {
        vulnerabilities.push({
          id: 'missing-hsts',
          severity: 'medium',
          title: 'Missing HSTS Header',
          description: 'HTTP Strict Transport Security (HSTS) is not enabled.',
          cause: 'HSTS header is not configured in the web server.',
          affected: 'Transport Layer Security',
          recommendation: 'Enable HSTS with a long max-age value and includeSubDomains directive.',
          hasSolution: true,
        });
      }

    } catch (error) {
      // If HTTPS fails, it might indicate TLS issues
      if (url.startsWith('https://')) {
        vulnerabilities.push({
          id: 'tls-connection-failed',
          severity: 'high',
          title: 'TLS Connection Failed',
          description: 'Unable to establish secure HTTPS connection.',
          cause: 'SSL/TLS certificate may be invalid, expired, or using weak protocols.',
          affected: 'Transport Layer Security',
          recommendation: 'Verify SSL/TLS certificate is valid and up to date. Ensure TLS 1.2+ is enabled.',
          hasSolution: true,
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Checks cookie security configuration
   */
  private checkCookieSecurity(headers: Record<string, string>, target: string): Vulnerability[]  {
    const vulnerabilities: Vulnerability[] = [];
    const setCookie = headers['set-cookie'];

    if (setCookie) {
      const cookies = Array.isArray(setCookie) ? setCookie : [setCookie];
      const insecureCookies: string[] = [];

      for (const cookie of cookies) {
        const cookieLower = cookie.toLowerCase();
        
        if (!cookieLower.includes('secure')) {
          insecureCookies.push('Missing Secure flag');
        }
        if (!cookieLower.includes('httponly')) {
          insecureCookies.push('Missing HttpOnly flag');
        }
        if (!cookieLower.includes('samesite')) {
          insecureCookies.push('Missing SameSite attribute');
        }
      }

      if (insecureCookies.length > 0) {
        vulnerabilities.push({
          id: 'cookie-security',
          severity: 'medium',
          title: 'Insecure Cookie Configuration',
          description: `Cookies are not properly secured: ${[...new Set(insecureCookies)].join(', ')}`,
          cause: 'Application or framework does not set proper cookie security attributes.',
          affected: 'Cookie Configuration',
          recommendation: 'Set Secure, HttpOnly, and SameSite attributes on all cookies.',
          hasSolution: true,
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Checks CORS configuration
   */
  private checkCORSConfiguration(headers: Record<string, string>, target: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const corsHeader = headers['access-control-allow-origin'];

    if (corsHeader === '*') {
      vulnerabilities.push({
        id: 'cors-wildcard',
        severity: 'medium',
        title: 'Overly Permissive CORS Policy',
        description: 'CORS policy allows requests from any origin (Access-Control-Allow-Origin: *).',
        cause: 'CORS is configured to accept requests from all domains.',
        affected: 'Cross-Origin Resource Sharing',
        recommendation: 'Restrict CORS to specific trusted domains instead of using wildcard (*).',
        hasSolution: false,
      });
    }

    if (headers['access-control-allow-credentials'] === 'true' && corsHeader === '*') {
      vulnerabilities.push({
        id: 'cors-credentials-wildcard',
        severity: 'high',
        title: 'Dangerous CORS Configuration',
        description: 'CORS allows credentials with wildcard origin, which is a security risk.',
        cause: 'Both Access-Control-Allow-Credentials and wildcard origin are enabled.',
        affected: 'Cross-Origin Resource Sharing',
        recommendation: 'Never use wildcard origin when allowing credentials. Specify exact origins.',
        hasSolution: false,
      });
    }

    return vulnerabilities;
  }

  /**
   * Checks Content Security Policy
   */
  private checkCSP(headers: Record<string, string>, target: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    const csp = headers['content-security-policy'];

    if (!csp) {
      return []; // Already covered in missing headers check
    }

    // Check for unsafe CSP directives
    const unsafeDirectives: string[] = [];
    
    if (csp.includes("'unsafe-inline'")) {
      unsafeDirectives.push("'unsafe-inline' allows inline scripts");
    }
    if (csp.includes("'unsafe-eval'")) {
      unsafeDirectives.push("'unsafe-eval' allows eval() and similar functions");
    }
    if (csp.includes('*') && !csp.includes("'self'")) {
      unsafeDirectives.push('Wildcard (*) source without restrictions');
    }

    if (unsafeDirectives.length > 0) {
      vulnerabilities.push({
        id: 'weak-csp',
        severity: 'medium',
        title: 'Weak Content Security Policy',
        description: `CSP contains unsafe directives: ${unsafeDirectives.join(', ')}`,
        cause: 'Content Security Policy uses permissive directives that reduce protection.',
        affected: 'Content Security Policy',
        recommendation: 'Remove unsafe-inline and unsafe-eval. Use nonces or hashes for inline scripts.',
        hasSolution: false,
      });
    }

    return vulnerabilities;
  }

  /**
   * Performs deep scan for additional vulnerabilities
   */
  private async performDeepScan(url: string, response: any): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for information disclosure in headers
    const sensitiveHeaders = ['server', 'x-powered-by', 'x-aspnet-version'];
    const disclosedInfo: string[] = [];

    for (const header of sensitiveHeaders) {
      if (response.headers[header]) {
        disclosedInfo.push(`${header}: ${response.headers[header]}`);
      }
    }

    if (disclosedInfo.length > 0) {
      vulnerabilities.push({
        id: 'information-disclosure',
        severity: 'low',
        title: 'Information Disclosure in Headers',
        description: `Server reveals technology information: ${disclosedInfo.join(', ')}`,
        cause: 'Web server or framework exposes version information in HTTP headers.',
        affected: 'HTTP Response Headers',
        recommendation: 'Remove or obfuscate server version headers to prevent information leakage.',
        hasSolution: false,
      });
    }

    // Check response body for common issues
    if (response.body) {
      const bodyLower = response.body.toLowerCase();
      
      // Check for debug information
      if (bodyLower.includes('debug') || bodyLower.includes('stacktrace') || bodyLower.includes('exception')) {
        vulnerabilities.push({
          id: 'debug-info-exposed',
          severity: 'medium',
          title: 'Debug Information Exposed',
          description: 'Response contains debug information or stack traces.',
          cause: 'Application is running in debug mode or error handling exposes sensitive information.',
          affected: 'Application Configuration',
          recommendation: 'Disable debug mode in production and implement proper error handling.',
          hasSolution: false,
        });
      }

      // Check for default pages
      if (bodyLower.includes('welcome to nginx') || bodyLower.includes('apache2 ubuntu default page')) {
        vulnerabilities.push({
          id: 'default-page',
          severity: 'low',
          title: 'Default Server Page Detected',
          description: 'Server is showing default installation page.',
          cause: 'Web server is not properly configured with custom content.',
          affected: 'Server Configuration',
          recommendation: 'Replace default pages with custom content or disable directory listing.',
          hasSolution: false,
        });
      }
    }

    return vulnerabilities;
  }
}
